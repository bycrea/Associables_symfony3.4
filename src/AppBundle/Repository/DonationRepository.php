<?php

namespace AppBundle\Repository;

use AppBundle\Entity\Donation;
use DateTime;
use Doctrine\ORM\Mapping\OrderBy;

/**
 * DonationRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class DonationRepository extends \Doctrine\ORM\EntityRepository
{
    /**
     * @param $id_asso
     * @param null $id_user
     * @param null $id_cookie
     * @return mixed
     * @throws \Doctrine\ORM\NonUniqueResultException
     *
     * Vérifie si un dons existe déjà dans le panier(payment_status = 0)
     * vis à vis d'une association et d'un utilisateur (id_user ou id_cookie)
     */
    public function existingBasketDonation($id_asso, $id_user = null, $id_cookie = null)
    {
        // Crée un nouveau $queryBuilder pour préparer notre requête DQL en lien avec l'entity Donation
        $queryBuilder = $this->createQueryBuilder('donation');

        $queryBuilder
            // On join l'entity Assos à notre requête
            ->leftJoin('donation.assos', 'asso')
            // là ou l'id de assos correspond à notre paramètre
            ->where('asso.id = :id_asso')
            ->setParameter('id_asso', $id_asso)
            // et OU le status de paiement est égal à la constante PAY_BASKET(=0)
            ->andWhere('donation.paymentStatus = :status')
            ->setParameter('status', Donation::PAY_BASKET);

        if(!is_null($id_user))
        {
            // et OU l'id_user correspond si l'utilisateur est conecté
            $queryBuilder
                ->leftJoin('donation.user', 'user')
                ->andWhere('user.id = :id_user')
                ->setParameter('id_user', $id_user);
        } else {
            // et OU l'id_cookie correspond dans le cas contraire
            $queryBuilder
                ->andWhere('donation.cookieId = :id_cookie')
                ->setParameter('id_cookie', $id_cookie);
        }

        // Retourne un objet OU null
        return $queryBuilder->getQuery()->getOneOrNullResult();
    }

    /**
     * @param null $id_user
     * @param null $id_cookie
     * @return array
     *
     * Compte le nombre de dons associés au Panier d'un Utilisateur (id_user ou id_cookie)
     * ET
     * La somme total de tous ces dons.
     */
    public function getBasketTotal($id_user = null, $id_cookie = null)
    {
        // Crée un nouveau $queryBuilder pour préparer notre requête DQL en lien avec l'entity Donation
        $queryBuilder = $this->createQueryBuilder('don');

        $queryBuilder
            // On utilise la fonction SQL count() pour retourner le nombre d'id donation
            ->select('count(don.id) as quantity, SUM(don.amount) as amount')
            // là OU le status de paiement est égal à la constante PAY_BASKET(=0)
            ->where('don.paymentStatus = :status')
            ->setParameter('status', Donation::PAY_BASKET);

        if(!is_null($id_user))
        {
            // et OU l'id_user correspond si l'utilisateur est conecté
            $queryBuilder
                ->leftJoin('don.user', 'user')
                ->andWhere('user.id = :id_user')
                ->setParameter('id_user', $id_user);
        } else {
            // et OU l'id_cookie correspond dans le cas contraire
            $queryBuilder
                ->andWhere('don.cookieId = :id_cookie')
                ->setParameter('id_cookie', $id_cookie);
        }

        // Retourne un tableau des résultats (index : 'quantity' , 'amount')
        $resultArray = $queryBuilder->getQuery()->getScalarResult();

        // Si amount = null on converti en 'int 0' pour l'affichage
        if(is_null($resultArray[0]['amount'])) { $resultArray[0]['amount'] = 0; }

        return $resultArray[0];
    }

    /**
     * @param $day
     * @return array
     * @throws \Exception
     *
     * Retoune les donations "expirées" du panier
     * Là ou 'createdAt' est inférieur à 'new DateTime' moins le nombre de jours '$day'
     * et 'paymentStatus = 0'
     */
    public function getExpiredDonations($day)
    {
        // Initialise un nouveau DateTime
        $todayDate = new DateTime();

        // Modifie la date - le nombre de jours entré en paramètre '$day'
        $expiredDate = $todayDate->modify('-'.$day.' day');

        $queryBuilder = $this->createQueryBuilder('don');

        $queryBuilder
            ->where('don.paymentStatus = :status')
            ->setParameter('status', Donation::PAY_BASKET)
            ->andWhere('don.createdAt < :expiredDate')
            ->setParameter('expiredDate', $expiredDate);

        return $queryBuilder->getQuery()->getResult();
    }


    /**
     * @param $year //année recherché
     * @param null $user //utilisateur connecté (tous si null)
     * @param array null $status //status du paiement (tous si null)
     * @return array
     *
     * Retourne les donations de l'année sélectionné ( YEAR() )
     *
     * Intallation du Bundle https://github.com/beberlei/DoctrineExtensions
     * qui permet de rajouter des méthode DQL telque YEAR() / MONTH() etc.
     */
    public function findDonationsByYear($year, $user)
    {
        $queryBuilder = $this->createQueryBuilder('don');

        $queryBuilder
            ->where('YEAR(don.createdAt) = :year')
            ->setPArameter('year', $year)

            ->andWhere('don.user = :user')
            ->setParameter('user', $user)

            ->andWhere('don.paymentStatus IN (:status)')
            ->setParameter('status', [Donation::PAY_IN_TRANSFER, Donation::PAY_PROCESSED])

            ->orderBy('don.createdAt', 'DESC');

        return $queryBuilder->getQuery()->getResult();
    }


    /**
     * @param $year
     * @param null $asso
     * @param null $user
     * @param array|null $status
     * @return array
     *
     * Retourne les donations selon l'année / l'asso / l'user / le status paiement Sélectionées
     */
    public function adminDonationsFilter($year, $asso = null, $user = null, array $status = null)
    {
        $queryBuilder = $this->createQueryBuilder('don');

        $queryBuilder
            ->where('YEAR(don.createdAt) = :year')
            ->setPArameter('year', $year);

        // Possibilité de trier par associations
        if(!empty($asso))
        {
            $queryBuilder
                ->andWhere('don.assos = :asso')
                ->setParameter('asso', $asso);
        }

        // Possibilité de trier par utilisateur
        if(!empty($user))
        {
            $queryBuilder
                ->andWhere('don.user = :user')
                ->setParameter('user', $user);
        }

        // Possibilité de trier par status de paiement
        if($status != null)
        {
            $queryBuilder
                ->andWhere('don.paymentStatus IN (:status)')
                ->setParameter('status', $status);
        }

        $queryBuilder
            ->orderBy('don.createdAt', 'DESC');

        return $queryBuilder->getQuery()->getResult();
    }


    /**
     * @param $donations
     * @return int
     *
     * Retourne le montant total des donations définies en paramètre
     */
    public function getDonationsTotalAmount($donations)
    {
        $totalAmount = 0;
        foreach ($donations as $don)
        {
            $totalAmount += $don->getAmount();
        }

        return $totalAmount;
    }
}
